import sys

LF = '\n'

max_callbacks = 8
max_wrapper_args = 10
no_tls = False
no_thread = False

for arg in sys.argv[1:]:
    arg_name, *arg_val = arg.split("=", 1)
    arg_val = arg_val[0] if arg_val else None
    if arg_name == "MAX_CALLBACKS":
        max_callbacks = int(arg_val)
    elif arg_name == "MAX_WRAPPER_ARGS":
        max_wrapper_args = int(arg_val)
    elif arg_name == "NO_TLS":
        no_tls = True
    elif arg_name == "NO_THREAD":
        no_thread = True
    else:
        assert 0, f'unknown option "{arg_name}"'

template = """\
/* generated by mcp_forth_generator.py */


#ifdef MCP_FORTH_GENERATED_DEFINES

{defines}

#endif /*MCP_FORTH_GENERATED_DEFINES*/


#ifdef MCP_FORTH_GENERATED_MCP_FORTH_DECLARATION

{wrapper_decls}

#endif /*MCP_FORTH_GENERATED_MCP_FORTH_DECLARATION*/


#ifdef MCP_FORTH_GENERATED_MCP_FORTH_DEFINITION

{wrappers}

{var_arg_wrappers}

#endif /*MCP_FORTH_GENERATED_MCP_FORTH_DEFINITION*/


#ifdef MCP_FORTH_GENERATED_VM_ENGINE

{vm_engine_callback_targets}

{vm_engine_callback_target_array}

#endif /*MCP_FORTH_GENERATED_VM_ENGINE*/


#ifdef MCP_FORTH_GENERATED_X86_32_ENGINE

{x86_32_engine_callback_targets}

{x86_32_engine_callback_target_array}

#endif /*MCP_FORTH_GENERATED_X86_32_ENGINE*/


#ifdef MCP_FORTH_GENERATED_ESP32S3_ENGINE

{esp32s3_engine_callback_targets}

{esp32s3_engine_callback_target_array}

#endif /*MCP_FORTH_GENERATED_ESP32S3_ENGINE*/
"""

nasm_template = """\
%ifndef MCP_FORTH_GENERATED_MAC 
%define MCP_FORTH_GENERATED_MAC 

%define M4_MAX_CALLBACKS {max_callbacks}

%endif
"""


defines = f"""\
#define M4_MAX_CALLBACKS {max_callbacks}
#ifndef M4_NO_TLS
    {"#define M4_NO_TLS" if no_tls else "/*#define M4_NO_TLS*/"}
#endif
#ifndef M4_NO_THREAD
    {"#define M4_NO_THREAD" if no_thread else "/*#define M4_NO_THREAD*/"}
#endif\
"""

wrapper_decls = "\n".join(f"""\
int m4_f0{i}(void * param, m4_stack_t * stack);
int m4_f1{i}(void * param, m4_stack_t * stack);"""
    for i in range(1, max_wrapper_args + 1)
)

wrappers = "\n\n".join(f"""\
int m4_f0{i}(void * param, m4_stack_t * stack)
{{
    if(!(stack->len >= {i})) return M4_STACK_UNDERFLOW_ERROR;
    void (*func)({', '.join('int' for _ in range(i))}) = param;
    stack->data -= {i};
    stack->len -= {i};
    func({', '.join(f'stack->data[{j}]' for j in range(i))});
    return 0;
}}

int m4_f1{i}(void * param, m4_stack_t * stack)
{{
    if(!(stack->len >= {i})) return M4_STACK_UNDERFLOW_ERROR;
    int (*func)({', '.join('int' for _ in range(i))}) = param;
    stack->data -= {i};
    stack->len -= {i};
    int y = func({', '.join(f'stack->data[{j}]' for j in range(i))});
    if(!(stack->len < stack->max)) return M4_STACK_OVERFLOW_ERROR;
    stack->data[0] = y;
    stack->data += 1;
    stack->len += 1;
    return 0;
}}"""
    for i in range(1, max_wrapper_args + 1)
)

var_arg_wrappers_0_cases = ''.join(f"""
        case {i}:
            return m4_f0{i}(param, stack);"""
    for i in range(max_wrapper_args + 1)
)
var_arg_wrappers_1_cases = ''.join(f"""
        case {i}:
            return m4_f1{i}(param, stack);"""
    for i in range(max_wrapper_args + 1)
)

var_arg_wrappers = f"""int m4_f0x(void * param, m4_stack_t * stack)
{{
    if(!(stack->len >= 1)) return M4_STACK_UNDERFLOW_ERROR;
    stack->data -= 1;
    stack->len -= 1;
    switch (stack->data[0]) {{\
{var_arg_wrappers_0_cases}
    }}
    return M4_TOO_MANY_VAR_ARGS_ERROR;
}}

int m4_f1x(void * param, m4_stack_t * stack)
{{
    if(!(stack->len >= 1)) return M4_STACK_UNDERFLOW_ERROR;
    stack->data -= 1;
    stack->len -= 1;
    switch (stack->data[0]) {{\
{var_arg_wrappers_1_cases}
    }}
    return M4_TOO_MANY_VAR_ARGS_ERROR;
}}"""

vm_engine_callback_targets = '\n'.join(f"""\
static int callback_target_{i}(int arg1, ...) {{
    va_list ap;
    va_start(ap, arg1);
    int ret = callback_handle({i}, arg1, ap);
    va_end(ap);
    return ret;
}}"""
    for i in range(max_callbacks)
)

vm_engine_callback_target_array = f"""\
static int (*const callback_targets[M4_MAX_CALLBACKS])(int arg1, ...) = {{\
{''.join(f'{LF}    callback_target_{i},' for i in range(max_callbacks))}
}};"""

x86_32_engine_callback_targets = '\n'.join(
    f"int m4_x86_32_engine_callback_target_{i}(int arg1, ...);"
    for i in range(max_callbacks)
)

x86_32_engine_callback_target_array = f"""\
static const callback_target_t callback_targets[M4_MAX_CALLBACKS] = {{\
{''.join(f'{LF}    m4_x86_32_engine_callback_target_{i},' for i in range(max_callbacks))}
}};"""

esp32s3_engine_callback_targets = '\n'.join(
    f"int m4_esp32s3_engine_callback_target_{i}(int arg1, ...);"
    for i in range(max_callbacks)
)

esp32s3_engine_callback_target_array = f"""\
static const callback_target_t callback_targets[M4_MAX_CALLBACKS] = {{\
{''.join(f'{LF}    m4_esp32s3_engine_callback_target_{i},' for i in range(max_callbacks))}
}};"""

generated = template.format(
    defines = defines,
    wrapper_decls = wrapper_decls,
    wrappers = wrappers,
    var_arg_wrappers = var_arg_wrappers,
    vm_engine_callback_targets = vm_engine_callback_targets,
    vm_engine_callback_target_array = vm_engine_callback_target_array,
    x86_32_engine_callback_targets = x86_32_engine_callback_targets,
    x86_32_engine_callback_target_array = x86_32_engine_callback_target_array,
    esp32s3_engine_callback_targets = esp32s3_engine_callback_targets,
    esp32s3_engine_callback_target_array = esp32s3_engine_callback_target_array,
)

nasm_generated = nasm_template.format(
    max_callbacks = max_callbacks,
)

with open("mcp_forth_generated.h", "w") as f:
    f.write(generated)

with open("mcp_forth_generated.mac", "w") as f:
    f.write(nasm_generated)
